% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/directed-depth-first.R
\name{directed_depth_first}
\alias{directed_depth_first}
\title{Make an EMST directed and return the depth-first search order}
\usage{
directed_depth_first(tree, edges, root_id)
}
\arguments{
\item{`tree`}{(\code{environment}) A potentially undirected tree, originally from
\code{\link[=tree_from_edges]{tree_from_edges()}}.}

\item{`edges`}{A data frame with one row per edge, and at least the two
\code{numeric} columns \code{from} and \code{to} for the IDs of the nodes being connected
by the edge.  Must be the same as was used by \code{\link[=tree_from_edges]{tree_from_edges()}} to create
\code{tree} from the output of \code{\link[emstreeR:ComputeMST]{emstreeR::ComputeMST()}}.}

\item{`root_id`}{(\code{numeric}) The ID of the node to treat as the root.}
}
\value{
A list containing \code{edges} with some values of the \code{to} and \code{from} columns
exchanged so that the graph is directed, and \code{dfs_order}, which is a vector
of node IDs in the order that they would be visited in a depth-first search.
the \code{tree} is modified in place, so is not returned.
}
\description{
Euclidean Minimum Spanning Tree (EMST) edgelists from
\code{\link[emstreeR:ComputeMST]{emstreeR::ComputeMST()}} aren't directed.  We also need to know a depth-first
search order of the nodes, to traverse them in loops rather than by
recursion, which would reach the stack limit.  This function does both.  A
list is returned containing the modified \code{edges}, and a \code{dfs_order} element
that names the nodes in depth-first search order.  The \code{tree} is modified in
place.
}
